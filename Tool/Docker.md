# Docker

容器化 = 封装 + 隔离
分布式 = 集群 +

Docker images contain the code that is needed to run an application.
Docker containers are the isolated environments that are running the code from Docker images.
Docker volumes are used to persist data that is generated by running Docker containers.
Docker networks are used to allow containers to communicate with each other and isolated from the environment.

The Docker engine is a long-running background process that can be interacted with via a REST API.
The Docker CLI is the way most people interact with the REST API to manage Docker objects.

Podman is a daemonless, doesn’t require an active container engine for its commands to work.
Images created by Docker and Podman are compatible with the OCI standard.
Containers can either be run as root or in rootless mode.
Podman is complete CLI compatible with Docker.

```
pacman -S podman
alias docker=podman
```

```
podman generate systemd --new $container
```

By default, Podman generates a unit that starts and stops an existing container.
The --new flag instructs Podman to generate units that create, start, and remove containers.

Docker containers share the same Linux operating system kernel on a machine.
For Mac OS or Windows, a lightweight Linux kernel runs on a hypervisor.

A Dockerfile is a file that holds the instructions on how to build an image.

Frequently used instructions:
| Instruction | Description |
|-------------|----------------------------------------------------------|
| FROM | Imports a base image |
| RUN | Executes command in a new image layer |
| WORKDIR | Defines the working directory for subsequent instructions in the Dockerfile |
| COPY | Copies files/directories into the image |
| ADD | A more feature\-rich version of the COPY instruction\. COPY is preferred over ADD\. |
| VOLUME | Defines which directory in an image should be treated as a volume\. The volume will be given a random name which can be found using docker inspect command\. |
| CMD | Command to be executed when running a container |
| ENTRYPOINT | Define a container's executable\. |
| EXPOSE | Documents which ports are exposed |
| ENV | Sets environment variables |
| ARG | Defines variables that can be passed by the docker build \-\-build\-arg command and used within the Dockerfile\. |

- [The difference between CMD and ENTRYPOINT](https://phoenixnap.com/kb/docker-cmd-vs-entrypoint)

A .dockerignore file can be added at the same level as the Dockerfile to specify files will be ignored and not added into the Docker image.

The best way to avoid including unnecessary files in Docker images is by using multi-stage builds in a Dockerfile. Multi-stage builds allow "intermediate" images to be built where any necessary compile-time dependencies can be installed and then only the necessary files generated from these intermediate images can be copied into an optimized runtime image.

- [How multi-stage builds work](https://codesalad.dev/blog/smaller-docker-images-using-multi-stage-builds-8)

Docker images can be saved to image registries for others to download the images.
The default Docker image registry is [Docker Hub](https://hub.docker.com/).

Docker image tags are mutable, which means that tagged image can be overwritten with a different image that contains different code. Mutable image tags have their benefits (such as making sure previously published versions of an image include security fixes), but this also could result in non-deterministic deployments.

- [Overcoming Docker’s Mutable Image Tags](https://renovate.whitesourcesoftware.com/blog/overcoming-dockers-mutable-image-tags/)

### Docker Desktop

Docker Desktop is an easy-to-install application for Mac or Windows environment that enables you to build and share containerized applications and microservices. Docker Desktop includes Docker Engine, Docker CLI client, Docker Compose, Notary, Kubernetes, and Credential Helper.

From the Docker menu, select Dashboard.

The Docker Dashboard provides a simple interface that enables you to manage your containers, applications, and images directly from your machine without having to use the CLI to perform core actions.

- See also [DockStation](https://dockstation.io/)

## 安装

```
pacman -S docker
systemctl start docker
systemctl enable docker
```

## 普通用户使用 docker

```
sudo usermod -aG docker $(whoami)
```

logout & login again

## 访问 insecure-registries

Create or modify /etc/docker/daemon.json
{ "insecure-registries":["myregistry.example.com:5000"] }
Restart docker daemon
sudo systemctl restart docker

## allows IP forwarding from the container

```
nano /etc/systemd/network/<interface>.network
```

```
[Network]
...
IPForward=kernel
...
```

## 常用命令

```
docker version 查看docker的版本信息
docker info 列出全局信息
docker run hello-world 测试docker能否正常运行

docker pull image_name 从仓库获取所需要的镜像
docker images 列出镜像
docker image prune -f 清理未被使用的镜像文件
docker ps -a 列出容器
docker ps --format "{{.ID}}: {{.Command}}"

docker create --name string -p host_port:container_port -v host_path:container_path IMAGE [COMMAND] [ARG...] 新建一个容器
docker rename CONTAINER NEW_NAME 给容器重命名

# 新建并启动容器，-t分配一个伪终端并绑定到容器的标准输入上， -i则让容器的标准输入保持打开，-d则进入后台运行
# --rm 容器停止后自动删除 -P 发布所有容器暴露的端口到主机上随机的端口号
docker run -it image_name:tag_name /bin/bash

# run multiple commands in docker, use /bin/bash -c and semicolon ;
docker run image /bin/bash -c "cd /path/to/somewhere; python a.py"

docker commit container_id image_name:tag_name 提交容器中的改动到镜像文件中
docker start container_id 启动容器
docker attach container_id 进入运行中的容器
exit 从容器中退出
docker start -a container_id 启动并进入容器
docker stop container_id 停止容器
docker restart container_id 重启动容器
docker restart $(docker ps -aq) 重启所有停止的容器

docker inspect container_id 查看容器详情
docker logs -f --tail 300 container_id 查看容器的日志
docker stats container_id* 查看容器资源使用情况

docker exec CONTAINER COMMAND 在容器内执行任意command
docker exec -it CONTAINER bash 进入容器的terminal
docker run -it --entrypoint /bin/bash IMAGE_NAME 在运行时指定entrypoint
# entrypoint作为容器中pid为1的进程运行，未指定时缺省为 /bin/sh -c，cmd只是entrypoint的参数。

docker cp CONTAINER:/FILE_PATH LOCAL_PATH
docker cp LOCAL_PATH CONTAINER:/FILE_PATH

docker pause CONTAINER 暂停容器中所有进程
docker unpause CONTAINER 继续容器中所有进程
docker top CONTAINER 和在容器里执行 top 的效果类似

docker rm 删除容器
docker rmi 删除镜像

docker volume ls 列出分卷
docker volume create --name volume_name 创建分卷
docker volume inspect volume_name 查看分卷
docker volume rm volume_name 删除分卷

docker network ls 列出网络
docker run --network=host image_name 使用host网络
网络选项：
- bridge 默认值，连接到默认的桥接网络，
- host 直接使用主机的网络连接，主机与容器之间没有隔离
- overlay 跨主机的虚拟网络
- none 禁用网络

docker save -o busybox.tar busybox 导出镜像为tar文件
gzip busybox.tar 压缩tar文件
docker save busybox | gzip > busybox.tar.gz 导出并压缩镜像
docker load -i busybox.tar.gz 从tar.gzi文件导入镜像

docker system df 查看 Docker 使用了多少资源
docker system prune 删除当前没有被使用的一切项目
docker volume prune 删除所有（本地）没有被容器使用的 volume
```

## 构建 image 文件

```
git clone https://github.com/emk/rust-musl-builder.git
cd rust-musl-builder
docker build --build-arg TOOLCHAIN=nightly -t rust-musl-builder .
```

## 发布镜像文件

```
docker login --username=liujf
docker tag NAME liujf/NAME[:TAG]
docker push liujf/NAME[:TAG]
```

## Run a local registry

```
docker run -d -p 5000:5000 --restart=always --name registry registry:2
docker tag ubuntu:16.04 localhost:5000/my-ubuntu
docker push localhost:5000/my-ubuntu
```

## 允许通过 tcp 端口远程控制

https://success.docker.com/article/how-do-i-enable-the-remote-api-for-dockerd

## Swarm 集群

```
# 在管理节点上创建一个新的swarm，其他节点以worker或manager的方式加入swarm
docker swarm init --advertise-addr 192.168.33.101 (在管理节点上运行)
docker swarm join \
--token SWMTKN-1-4d8z30svnj6wi8y64ttzirpildro5vego1qrrldepj8auwxa6l-4l4b6o7q1wnjyiwsubkpffkkn \
192.168.33.101:2377 (在worker节点上运行)

docker swarm join-token worker 查看加入swarm的命令
docker node ls 查看集群中的所有节点
docker node promote <worker_node> worker节点上升为manager节点(在管理节点上运行)
```

### 在 Swarm 集群上运行 service

服务模式包括 replicated 和 global。默认是 replicated。

- replicated 模式，根据指定的数量运行任务。
- global 模式，任务运行在集群中所有活跃的节点上。

```
docker service create --name <service name> --mode <mode> alpine ping 8.8.8.8
docker service ls
docker service ps <service name> 查看服务到底跑在哪个节点服务器上
docker service scale <service name>=<副本个数>
```

### 发布端口

- 公共的端口会暴露在每一个 swarm 集群中的节点服务器上.
- 请求进如公共端口后会负载均衡到所有的 sevice 实例上.

```
docker service create --name search --publish 9200:9200 --replicas 7 elasticsearch
watch docker service ps search 监控 service 创建过程
docker service rm <service ID or Name> 删除服务
docker service ls -q | xargs docker service rm 删除所有servcie
```

一个 service 副本的创建过程,会经历以下几个状态:

- accepted 任务已经被分配到某一个节点执行
- preparing 准备资源, 现在来说一般是从网络拉取 image
- running 副本运行成功
- shutdown 呃, 报错,被停止了…

### Rolling Update

--update-parallelism 指定每次 update 的容器数量, --update-delay 每次更新之后的等待时间.
回滚和更新的命令是相同的，只是指定不同的镜像.

```
docker service update <service name> --update-parallelism 2 --update-delay 5s --image <updated image>
```

### overlay 网络

保证不同主机上的容器网络互通

```
docker network create --driver overlay <network name>
docker network ls
docker service create --network <network name> --name <service name> <image name> 在指定网络上创建service
```

## 容器运维最佳实践

- 容器可以将日志写入 stdout 和 stderr，Docker 捕获这些日志行，并允许你使用 docker logs 命令访问它们。
- 确保容器是无状态且不可变的，这意味着可以随时干净地关闭和销毁容器，而不必担心数据丢失。
- 更新应用程序代码或打补丁，则构建新镜像并重新部署。不变性使部署更安全，更可重复。如果需要回滚，只需重新部署旧镜像即可。
- 请避免使用特权容器。特权容器可以访问主机的所有设备，绕过容器的几乎所有安全功能。

## Docker Compose

Docker Compose allows for the definition of containers to be done in docker-compose.yml files.

```
docker-compose build
docker-compose up
docker-compose down
```
